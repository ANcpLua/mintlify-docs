---
title: Extensions
description: Opt-in extensions for specialized use cases
icon: "cube"
---


Opt-in extensions for specialized use cases.

## Comparers

# Comparers

Internal ordinal string comparers (singleton) for consistent, allocation-free comparisons.

To use this in your project, add the following to your `.csproj` file:

```xml
<PropertyGroup>
  <InjectStringOrdinalComparer>true</InjectStringOrdinalComparer>
</PropertyGroup>
```

## What gets injected

Reference only: the following C# is shown just to illustrate how the injected code looks.
You do not copy/paste or add these files manually.

<Accordion title="StringOrdinalComparer.cs (injected)">

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;

namespace ANcpLua.NET.Sdk.Shared.Extensions.Comparers;

/// <summary>
///     A singleton ordinal string comparer for consistent, allocation-free comparisons.
/// </summary>
internal sealed class StringOrdinalComparer : IComparer<string>, IEqualityComparer<string>
{
    /// <summary>Gets the singleton instance.</summary>
    public static readonly StringOrdinalComparer Instance = new();

    private StringOrdinalComparer()
    {
    }

    /// <inheritdoc />
    public int Compare(string? x, string? y)
    {
        return StringComparer.Ordinal.Compare(x, y);
    }

    /// <inheritdoc />
    public bool Equals(string? x, string? y)
    {
        return StringComparer.Ordinal.Equals(x, y);
    }

    /// <inheritdoc />
    public int GetHashCode(string obj)
    {
        return StringComparer.Ordinal.GetHashCode(obj);
    }
}

/// <summary>
///     A singleton ordinal case-insensitive string comparer.
/// </summary>
internal sealed class StringOrdinalIgnoreCaseComparer : IComparer<string>, IEqualityComparer<string>
{
    /// <summary>Gets the singleton instance.</summary>
    public static readonly StringOrdinalIgnoreCaseComparer Instance = new();

    private StringOrdinalIgnoreCaseComparer()
    {
    }

    /// <inheritdoc />
    public int Compare(string? x, string? y)
    {
        return StringComparer.OrdinalIgnoreCase.Compare(x, y);
    }

    /// <inheritdoc />
    public bool Equals(string? x, string? y)
    {
        return StringComparer.OrdinalIgnoreCase.Equals(x, y);
    }

    /// <inheritdoc />
    public int GetHashCode(string obj)
    {
        return StringComparer.OrdinalIgnoreCase.GetHashCode(obj);
    }
}
```

</Accordion>

## FakeLogger

# FakeLogger

Extensions for `FakeLogCollector` to assist with testing logging scenarios.

To use this in your project, add the following to your `.csproj` file:

```xml
<PropertyGroup>
  <InjectFakeLogger>true</InjectFakeLogger>
</PropertyGroup>
```

> **Note:** Requires a reference to `Microsoft.Extensions.Diagnostics.Testing` or equivalent where `FakeLogCollector` is defined.

## What gets injected

Reference only: the following C# is shown just to illustrate how the injected code looks.
You do not copy/paste or add these files manually.

<Accordion title="FakeLoggerExtensions.cs (injected)">

```csharp
// <auto-generated/>
#nullable enable
using System.Text;


public static class FakeLoggerExtensions
{
	public static string GetFullLoggerText(
		this FakeLogCollector source,
		Func<FakeLogRecord, string>? formatter = null)
	{
		StringBuilder sb = new();
		IReadOnlyList<FakeLogRecord> snapshot = source.GetSnapshot();
		formatter ??= record => $"{record.Level} - {record.Message}";

		foreach (FakeLogRecord record in snapshot)
		{
			sb.AppendLine(formatter(record));
		}

		return sb.ToString();
	}

	public static async Task<bool> WaitForLogAsync(
		this FakeLogCollector source,
		Func<IReadOnlyList<FakeLogRecord>, bool> condition,
		TimeSpan? timeout = null,
		TimeSpan? pollInterval = null,
		CancellationToken cancellationToken = default)
	{
		timeout ??= TimeSpan.FromSeconds(5);
		pollInterval ??= TimeSpan.FromMilliseconds(25);

		using CancellationTokenSource cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
		cts.CancelAfter(timeout.Value);

		try
		{
			while (!cts.Token.IsCancellationRequested)
			{
				if (condition(source.GetSnapshot()))
				{
					return true;
				}

				await Task.Delay(pollInterval.Value, cts.Token).ConfigureAwait(false);
			}
		}
		catch (OperationCanceledException) when (!cancellationToken.IsCancellationRequested)
		{
		}

		return condition(source.GetSnapshot());
	}

	public static Task<bool> WaitForLogCountAsync(
		this FakeLogCollector source,
		Func<FakeLogRecord, bool> predicate,
		int expectedCount,
		TimeSpan? timeout = null,
		CancellationToken cancellationToken = default) =>
		source.WaitForLogAsync(
			logs => logs.Count(predicate) >= expectedCount,
			timeout,
			cancellationToken: cancellationToken);
}
```

</Accordion>

## SourceGen

# SourceGen Helpers

Roslyn symbol extensions and helpers for Source Generators.

## Architecture

The SDK provides source generator helpers from **two sources**:

| Source | Purpose |
|--------|---------|
| `ANcpLua.Roslyn.Utilities.Sources` NuGet | Core utilities (~27 files) - embedded as internal types |
| `eng/Extensions/SourceGen/` | SDK-specific extensions (2 files) |

### Why Source-Only Packages?

Source generators **cannot easily reference external NuGet packages** at design-time. The Roslyn compiler loads generators in a constrained environment where package dependencies often fail to resolve.

**This is the industry-standard pattern** used by Microsoft and the .NET community:

| Use Case | Distribution | Why |
|----------|--------------|-----|
| Source generator projects | **Source-only package** (`InjectSourceGenHelpers`) | Generators can't easily use NuGet packages |
| Analyzers, CLI tools, tests | **ANcpLua.Roslyn.Utilities** NuGet package | Normal projects can reference packages |

## Usage

To use these helpers in your source generator project:

```xml
<PropertyGroup>
  <InjectSourceGenHelpers>true</InjectSourceGenHelpers>
</PropertyGroup>
```

This will:
1. Reference `ANcpLua.Roslyn.Utilities.Sources` package (embeds as internal types)
2. Include SDK-specific extension files
3. Define the `ANCPLUA_SOURCEGEN_HELPERS` constant

## What Gets Injected

When `InjectSourceGenHelpers=true`, you get access to:

### From ANcpLua.Roslyn.Utilities.Sources

- `EquatableArray<T>` - Cache-safe array wrapper for incremental generators
- `DiagnosticFlow` - Fluent diagnostic reporting
- `SymbolExtensions` - Symbol analysis helpers
- `TypeSymbolExtensions` - Type checking utilities
- `InvocationExtensions` - Method invocation matching
- `SyntaxValueProviderExtensions` - Pipeline helpers
- `CodeGeneration` - Code emission utilities
- `HashCombiner` - Hash code generation
- And more (~27 files total)

### SDK-Specific (this directory)

- `DiagnosticsExtensions.cs` - Additional diagnostic helpers
- `SyntaxValueProvider.cs` - Custom syntax providers

## Related Packages

- [`ANcpLua.Roslyn.Utilities`](https://nuget.org/packages/ANcpLua.Roslyn.Utilities) - For analyzers, CLI tools, tests
- [`ANcpLua.Roslyn.Utilities.Sources`](https://nuget.org/packages/ANcpLua.Roslyn.Utilities.Sources) - Source-only for generators


## Enabling Extensions

```xml
<PropertyGroup>
  <!-- Roslyn source generator utilities -->
  <InjectSourceGenHelpers>true</InjectSourceGenHelpers>

  <!-- FakeLogger for testing -->
  <InjectFakeLogger>true</InjectFakeLogger>
</PropertyGroup>
```
