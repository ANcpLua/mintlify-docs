---
title: Testing Infrastructure
description: Testing frameworks for analyzers, code fixes, refactorings, and source generators
icon: 'flask-vial'
---

`ANcpLua.Roslyn.Utilities.Testing` provides fluent base classes for testing Roslyn components:

| Base Class                         | Purpose                            |
| ---------------------------------- | ---------------------------------- |
| `AnalyzerTest<TAnalyzer>`          | Test diagnostic analyzers          |
| `CodeFixTest<TAnalyzer, TCodeFix>` | Test code fix providers            |
| `RefactoringTest<TRefactoring>`    | Test code refactoring providers    |
| `Test<TGenerator>`                 | Test incremental source generators |

<Note>
  These base classes work with xUnit v3's ambient `TestContext`. Use
  `TestContext.Current.TestOutputHelper` for diagnostic output without
  constructor injection.
</Note>

## Installation

```xml
<PackageReference Include="ANcpLua.Roslyn.Utilities.Testing" Version="1.15.0" />
```

## AnalyzerTest

Base class for testing diagnostic analyzers with pre-configured .NET 10 reference assemblies.

### Basic Usage

```csharp
using ANcpLua.Roslyn.Utilities.Testing;

public class MyAnalyzerTests : AnalyzerTest<MyAnalyzer>
{
    [Fact]
    public Task ShouldReportWarning() => VerifyAsync("""
        class C
        {
            void M() { {|MY001:BadCode()|}; }
        }
        """);

    [Fact]
    public Task ShouldNotReport() => VerifyAsync("""
        class C
        {
            void M() { GoodCode(); }
        }
        """);
}
```

<Note>
    Use diagnostic markup `{|DIAGNOSTIC_ID:code|}` to mark expected diagnostic locations.
</Note>

### Testing with Additional Files

For analyzers that inspect non-C# files (MSBuild props, JSON configs, etc.):

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Testing;

public class PropsAnalyzerTests : AnalyzerTest<MyPropsAnalyzer>
{
    [Fact]
    public Task ShouldWarnWhenMissingImport()
    {
        const string directoryBuildProps = """
            <Project>
                <PropertyGroup>
                    <SomeProperty>Value</SomeProperty>
                </PropertyGroup>
            </Project>
            """;

        var expected = new DiagnosticResult("MY001", DiagnosticSeverity.Warning)
            .WithLocation("Directory.Build.props", 1, 1);

        return VerifyAsync(
            source: "public class C { }",
            additionalFiles: [("Directory.Build.props", directoryBuildProps)],
            expectedDiagnostics: [expected]);
    }

    [Fact]
    public Task ShouldNotWarnWhenImportPresent()
    {
        const string directoryBuildProps = """
            <Project>
                <Import Project="Version.props" />
            </Project>
            """;

        // No expected diagnostics = verify clean compilation
        return VerifyAsync(
            source: "public class C { }",
            additionalFiles: [("Directory.Build.props", directoryBuildProps)]);
    }
}
```

### Target Framework Selection

```csharp
// Default: .NET 10 references
await VerifyAsync(source);

// For netstandard2.0 analyzers (e.g., source generators)
await VerifyAsync(source, useNet10References: false);
```

## CodeFixTest

Base class for testing code fix providers that transform diagnostic-marked code.

```csharp
using ANcpLua.Roslyn.Utilities.Testing;

public class MyCodeFixTests : CodeFixTest<MyAnalyzer, MyCodeFix>
{
    [Fact]
    public Task ShouldFixWarning() => VerifyAsync(
        source: """
            class C
            {
                void M() { {|MY001:BadCode()|}; }
            }
            """,
        fixedSource: """
            class C
            {
                void M() { GoodCode(); }
            }
            """);
}
```

<Tip>
  The test framework automatically runs the analyzer, triggers the code fix, and
  verifies the result matches `fixedSource`.
</Tip>

## RefactoringTest

<Note>New in v1.14.0</Note>

Base class for testing code refactoring providers (lightbulb suggestions without diagnostics).

### Basic Usage

```csharp
using ANcpLua.Roslyn.Utilities.Testing;

public class MakeStaticRefactoringTests : RefactoringTest<MakeStaticLambdaRefactoring>
{
    [Fact]
    public Task ShouldMakeLambdaStatic() => VerifyAsync(
        source: """
            using System;
            class C
            {
                Func<int, int> f = [|x => x * 2|];
            }
            """,
        fixedSource: """
            using System;
            class C
            {
                Func<int, int> f = static x => x * 2;
            }
            """);
}
```

<Note>
  Use span markup `[|code|]` to mark the refactoring trigger location.
</Note>

### Verifying No Refactoring Offered

```csharp
[Fact]
public Task ShouldNotOfferWhenAlreadyStatic() => VerifyNoRefactoringAsync("""
    using System;
    class C
    {
        Func<int, int> f = [|static x => x * 2|];
    }
    """);

[Fact]
public Task ShouldNotOfferWhenCapturing() => VerifyNoRefactoringAsync("""
    using System;
    class C
    {
        void M()
        {
            int captured = 5;
            Func<int, int> f = [|x => x + captured|];
        }
    }
    """);
```

## GeneratorTest

Fluent API for testing Roslyn incremental source generators with built-in caching validation.

### Basic Usage

```csharp
using ANcpLua.Roslyn.Utilities.Testing;

public class MyGeneratorTests
{
    [Fact]
    public async Task ShouldGenerateExpectedOutput()
    {
        const string source = """
            [GenerateDto]
            public partial class User
            {
                public string Name { get; set; }
            }
            """;

        using var result = await Test<MyGenerator>.Run(source);
        result
            .Produces("User.g.cs", """
                public partial class User
                {
                    public UserDto ToDto() => new(Name);
                }
                """)
            .IsCached()
            .IsClean();
    }
}
```

<Note>
    The `Test<TGenerator>` static class automatically runs your generator twice to validate incremental caching
    behavior.
</Note>

### Custom Configuration

For complex scenarios, use the configuration overload:

```csharp
[Fact]
public async Task ShouldHandleAdditionalText()
{
using var result = await Test < MyGenerator >.Run(engine => engine
    .WithSource("""
public partial class Config {
}
""")
    .WithAdditionalText("config.json", """{"setting": "value"}""")
.WithLanguageVersion(LanguageVersion.CSharp12)
    .WithStepTracking(true))

result.Produces("Config.g.cs").IsCached();
}
```

### GeneratorTestEngine Methods

| Method                                | Description                                       |
| ------------------------------------- | ------------------------------------------------- |
| `WithSource(string)`                  | Add C# source code to the compilation             |
| `WithAdditionalText(path, text)`      | Add an additional file (JSON, XML, etc.)          |
| `WithReference(MetadataReference)`    | Add a metadata reference                          |
| `WithLanguageVersion(version)`        | Set C# language version (default: latest)         |
| `WithReferenceAssemblies(assemblies)` | Set reference assemblies package                  |
| `WithAnalyzerConfigOptions(provider)` | Set MSBuild property access                       |
| `WithStepTracking(bool)`              | Enable/disable step tracking for caching analysis |

## GeneratorResult Assertions

The `GeneratorResult` class provides a fluent API for verifying generator output.

### Output Verification

```csharp
result
.Produces("Output.g.cs")                        // File exists
.Produces("Output.g.cs", expectedContent)       // Exact content match
.Produces("Output.g.cs", "partial class", exactMatch: false); // Contains
```

### Compilation Verification

```csharp
result
.IsClean()      // No diagnostics of any severity
.Compiles();    // No errors (warnings allowed)
```

### Diagnostic Assertions

```csharp
result
.HasDiagnostic("GEN001")                        // Diagnostic exists
.HasDiagnostic("GEN001", DiagnosticSeverity.Warning)  // With severity
.HasNoDiagnostic("GEN002");                     // Diagnostic absent
```

### Custom File Assertions

```csharp
result.File("Output.g.cs", content =>
{
Assert.Contains("public partial class", content);
Assert.DoesNotContain("private", content);
});
```

<Tip>
  `GeneratorResult` implements `IDisposable` and calls `Verify()` on dispose.
  Use `using var result = ...` to automatically throw on assertion failures.
</Tip>

## Caching Validation

Incremental generators must cache their outputs properly to avoid recomputation during IDE typing scenarios. The testing framework validates caching behavior automatically.

### Basic Caching Check

```csharp
result.IsCached();  // All pipeline steps must be cached
```

### Checking Specific Steps

```csharp
result.IsCached("TransformStep", "CombineStep");  // Only check named steps
```

### Understanding the Caching Report

```csharp
var report = result.CachingReport;

Console.WriteLine($"Generator: {report.GeneratorName}");
Console.WriteLine($"Produced output: {report.ProducedOutput}");

foreach (var step in report.ObservableSteps)
{
Console.WriteLine($"Step: {step.StepName}")
Console.WriteLine($"  Cached: {step.Cached}")
Console.WriteLine($"  Unchanged: {step.Unchanged}")
Console.WriteLine($"  Modified: {step.Modified}")
Console.WriteLine($"  New: {step.New}")
Console.WriteLine($"  Removed: {step.Removed}")
Console.WriteLine($"  Success: {step.IsCachedSuccessfully}")
}
```

### Forbidden Types

Certain Roslyn types must never be cached because they prevent proper incremental caching:

| Forbidden Type  | Reason                                      |
| --------------- | ------------------------------------------- |
| `ISymbol`       | Not value-equal across compilations         |
| `Compilation`   | Contains mutable state                      |
| `SemanticModel` | Tied to specific compilation                |
| `SyntaxNode`    | Reference identity, not structural equality |
| `SyntaxTree`    | Reference identity, not structural equality |
| `IOperation`    | Compilation-specific                        |

```csharp
// Validates no forbidden types in any step
result.HasNoForbiddenTypes();

// IsCached() automatically checks for forbidden types
result.IsCached();  // Fails if ISymbol, Compilation, etc. are cached
```

<Warning>
  Caching forbidden types causes memory leaks and IDE performance degradation.
  Extract primitive data (strings, booleans, etc.) from Roslyn types before
  caching.
</Warning>

## Step Tracking

Enable step tracking to analyze which pipeline steps were executed and their caching states.

### How Step Tracking Works

1. The test engine runs your generator twice with identical input
2. The first run populates the cache
3. The second run reveals caching behavior

### Step States

| State       | Description                                          |
| ----------- | ---------------------------------------------------- |
| `Cached`    | Output reused from previous run (optimal)            |
| `Unchanged` | Recomputed but produced same value (equality worked) |
| `Modified`  | Value changed between runs (cache miss)              |
| `New`       | Additional item produced                             |
| `Removed`   | Item no longer produced                              |

A successfully cached step produces only `Cached` or `Unchanged` outputs.

### Named Step Tracking

Use `WithTrackingName` in your generator to enable fine-grained analysis:

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
var provider = context.SyntaxProvider
    .CreateSyntaxProvider(...)
    .WithTrackingName("ParseStep");  // Named for testing

var combined = provider
    .Combine(context.CompilationProvider)
    .WithTrackingName("CombineStep");

context.RegisterSourceOutput(combined, ...);
}
```

Then verify specific steps:

```csharp
result.IsCached("ParseStep", "CombineStep");
```

## Method Reference

### AnalyzerTest&lt;TAnalyzer&gt;

| Method                                                       | Description                                                    |
| ------------------------------------------------------------ | -------------------------------------------------------------- |
| `VerifyAsync(source)`                                        | Verify analyzer produces expected diagnostics marked in source |
| `VerifyAsync(source, additionalFiles, expectedDiagnostics?)` | Verify with additional files and explicit diagnostics          |

### CodeFixTest&lt;TAnalyzer, TCodeFix&gt;

| Method                             | Description                                          |
| ---------------------------------- | ---------------------------------------------------- |
| `VerifyAsync(source, fixedSource)` | Verify code fix transforms source to expected output |

### RefactoringTest&lt;TRefactoring&gt;

| Method                             | Description                                             |
| ---------------------------------- | ------------------------------------------------------- |
| `VerifyAsync(source, fixedSource)` | Verify refactoring transforms source to expected output |
| `VerifyNoRefactoringAsync(source)` | Verify no refactoring is offered at the marked span     |

### Test&lt;TGenerator&gt;

| Method           | Description                                 |
| ---------------- | ------------------------------------------- |
| `Run(source)`    | Run generator with source and return result |
| `Run(configure)` | Run generator with custom configuration     |

### GeneratorResult

| Method                               | Description                               |
| ------------------------------------ | ----------------------------------------- |
| `Produces(hintName)`                 | Assert file exists                        |
| `Produces(hintName, content)`        | Assert file exists with exact content     |
| `Produces(hintName, content, false)` | Assert file contains content              |
| `IsClean()`                          | Assert no diagnostics                     |
| `Compiles()`                         | Assert no errors (warnings allowed)       |
| `IsCached()`                         | Assert all steps are cached               |
| `IsCached(stepNames)`                | Assert specific steps are cached          |
| `HasDiagnostic(id)`                  | Assert diagnostic exists                  |
| `HasDiagnostic(id, severity)`        | Assert diagnostic exists with severity    |
| `HasNoDiagnostic(id)`                | Assert diagnostic does not exist          |
| `HasNoForbiddenTypes()`              | Assert no ISymbol/Compilation/etc. cached |
| `File(hintName, action)`             | Execute custom assertion on file content  |

### GeneratorCachingReport

| Property                  | Description                             |
| ------------------------- | --------------------------------------- |
| `GeneratorName`           | Name of the generator being tested      |
| `ProducedOutput`          | Whether generator produced any files    |
| `ObservableSteps`         | List of user-defined pipeline steps     |
| `ForbiddenTypeViolations` | List of cached forbidden types detected |

### GeneratorStepAnalysis

| Property               | Description                                |
| ---------------------- | ------------------------------------------ |
| `StepName`             | Name of the pipeline step                  |
| `Cached`               | Count of cached outputs                    |
| `Unchanged`            | Count of unchanged outputs                 |
| `Modified`             | Count of modified outputs                  |
| `New`                  | Count of new outputs                       |
| `Removed`              | Count of removed outputs                   |
| `HasForbiddenTypes`    | Whether step has forbidden type violations |
| `IsCachedSuccessfully` | True if no Modified/New/Removed outputs    |

## Test Project Patterns

### Minimal Generator Test Project

A clean generator test project requires only essential packages:

```xml
<Project Sdk="ANcpLua.NET.Sdk">
    <PropertyGroup>
        <TargetFramework>net10.0</TargetFramework>
        <OutputType>Exe</OutputType>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="xunit.v3.mtp-v2"/>
        <PackageReference Include="AwesomeAssertions"/>
        <PackageReference Include="Verify.XunitV3"/>
        <PackageReference Include="Verify.SourceGenerators"/>
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp"/>
        <PackageReference Include="ANcpLua.Roslyn.Utilities" GeneratePathProperty="true" PrivateAssets="all"/>
        <PackageReference Include="ANcpLua.Roslyn.Utilities.Testing"/>
    </ItemGroup>
    <ItemGroup>
        <ProjectReference Include="../MyGenerator/MyGenerator.csproj" OutputItemType="Analyzer"/>
    </ItemGroup>
    <ItemGroup>
        <Analyzer Include="$(PkgANcpLua_Roslyn_Utilities)/lib/netstandard2.0/ANcpLua.Roslyn.Utilities.dll"/>
    </ItemGroup>
</Project>
```

<Note>
  The `Analyzer` item loads ANcpLua.Roslyn.Utilities as an analyzer dependency
  alongside your generator.
</Note>

### Shared Test Base Class

Create a base class to centralize test infrastructure:

```csharp
using ANcpLua.Roslyn.Utilities.Testing;
using Microsoft.AspNetCore.Http;

namespace MyGenerator.Tests;

public abstract class GeneratorTestBase
{
    protected static readonly Type[] RequiredTypes =
    [
        typeof(HttpContext),
        // Add types your generator needs
    ];

    protected static async Task<GeneratorResult> RunAsync(string source)
    {
        using var scope = TestConfiguration.WithAdditionalReferences(RequiredTypes);
        return await Test<MyGenerator>.Run(source, TestContext.Current.CancellationToken);
    }

    protected static async Task VerifyAsync(string source)
    {
        using var result = await RunAsync(source);

        await Verify(new
        {
            GeneratedSources = result.Files
                .Select(static f => new { f.HintName, Source = f.Content })
                .OrderBy(static s => s.HintName),
            Diagnostics = result.Diagnostics
                .Select(static d => new { d.Id, Severity = d.Severity.ToString(), Message = d.GetMessage() })
                .OrderBy(static d => d.Id)
        }).UseDirectory("Snapshots");
    }
}
```

### Verify Module Initializer

Configure Verify for Roslyn types:

```csharp
using System.Runtime.CompilerServices;

namespace MyGenerator.Tests;

public static class ModuleInitializer
{
    [ModuleInitializer]
    public static void Initialize()
    {
        VerifySourceGenerators.Initialize();
        VerifierSettings.AddExtraSettings(static settings =>
            settings.Converters.Add(new EquatableArrayJsonConverter()));
    }
}

file sealed class EquatableArrayJsonConverter : WriteOnlyJsonConverter
{
    public override void Write(VerifyJsonWriter writer, object value)
    {
        var type = value.GetType();
        if (!type.IsGenericType || type.GetGenericTypeDefinition().Name != "EquatableArray`1")
        {
            writer.Serialize(value);
            return;
        }

        var itemsProperty = type.GetProperty("Items");
        var items = itemsProperty?.GetValue(value);
        if (items is null)
        {
            writer.WriteStartArray();
            writer.WriteEndArray();
            return;
        }

        var toArrayMethod = items.GetType().GetMethod("ToArray");
        writer.Serialize(toArrayMethod?.Invoke(items, null) ?? Array.Empty<object>());
    }

    public override bool CanConvert(Type type) =>
        type.IsGenericType && type.GetGenericTypeDefinition().Name == "EquatableArray`1";
}
```

### Test File Organization

```
tests/MyGenerator.Tests/
├── ModuleInitializer.cs      # Verify configuration
├── GeneratorTestBase.cs      # Shared infrastructure
├── GeneratorOutputTests.cs   # Output verification
├── AnalyzerDiagnosticTests.cs
└── Snapshots/                # Verify snapshot files
    └── *.verified.txt
```

<Tip>
  Keep tests focused: one test class per concern. Avoid duplicate test
  infrastructure across files.
</Tip>

## Integration Testing

For testing that requires real MSBuild execution (SDK features, package behavior, build-time code generation), see [MSBuild Testing](/utilities/msbuild-testing).

## Handling Type Ambiguity

If you encounter ambiguous reference errors between `Microsoft.CodeAnalysis.Testing.AnalyzerTest` and `ANcpLua.Roslyn.Utilities.Testing.AnalyzerTest`, use a type alias:

````csharp
using AnalyzerTestBase = ANcpLua.Roslyn.Utilities.Testing.AnalyzerTest<MyAnalyzer>;

    public class MyTests : AnalyzerTestBase
    {
        // ...
    }
    ```
````
